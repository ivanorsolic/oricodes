[
{
	"uri": "https://ori.engineering/rc-car/",
	"title": "RC Cars: a primer",
	"tags": [],
	"description": "",
	"content": "Prerequisite knowledge RC Cars: a primer Through this chapter we'll explore what kind of parts is a RC car comprised of, and what are the most important ones for us. We’ll use that knowledge while buying parts and assembling them for our hardware platform.\n"
},
{
	"uri": "https://ori.engineering/hardware-assembly/",
	"title": "Hardware assembly",
	"tags": [],
	"description": "",
	"content": "Hands on hardware Assembling the hardware Through this chapter we'll go through assembling the hardware platform, all things hardware.\n"
},
{
	"uri": "https://ori.engineering/rc-car/parts_list/",
	"title": "Parts: an overview",
	"tags": [],
	"description": "",
	"content": "There’s a lot of, and I mean a lot of parts when it comes to building an RC car on your own. But in the context of building a self-driving RC car, here’s a brief overview of some of the stuff we’ll need:\nYou'll want to have:  A RC car (with some batteries) A PWM/Servo Driver (I2C + some jumper cables) A Jetson Nano A powerbank (+ some usb cables) A microSD card (and optionally an external SSD) A WiFi/BT m.2 card (key E) or some USB equivalent Some tools and materials for building the chassis (and optionally access to a 3D printer) An Xbox/PS/PC gamepad  Let’s focus on the RC car (and the batteries) part for now.\nWhat RC car should I get? You can basically get any RC car, as long as it has an ESC controller, or you can hook up one to it.\n Some parts are more important than others, but here’s a overview of the parts we’ll be focusing on:\n Scale Body type Electric motor Servo ESC Receiver Batteries  "
},
{
	"uri": "https://ori.engineering/hardware-installation/",
	"title": "Hardware installation",
	"tags": [],
	"description": "",
	"content": "Hardware meets software Connecting everything together In this chapter we’ll go through connecting all of the hardware components together, and through installing the base software necessary for it to run.\n"
},
{
	"uri": "https://ori.engineering/host-pc/",
	"title": "Host PC",
	"tags": [],
	"description": "",
	"content": "Installing stuff on host PC "
},
{
	"uri": "https://ori.engineering/rc-car/scale/",
	"title": "Scale",
	"tags": [],
	"description": "",
	"content": " Most RC cars are scaled down versions of their real-life equivalent, so they're expressed in ratios, the most common ones being (real-life size : RC model size):\n  1:18 1:16 1:10 1:8 there are also all sorts of scales in between those (and above/below)  Of course, the question is: why do we care, and what's better for a self-driving RC car?\nIt's pretty simple:\n a bigger RC car equals more real estate and more power to carry all of our gadgets on top of it, without damaging the motors while struggling with all of the weight, but a bigger car needs a bigger race track and road size we want to drive it on  "
},
{
	"uri": "https://ori.engineering/rc-car/body_type/",
	"title": "RC Car body types",
	"tags": [],
	"description": "",
	"content": " The best body type for on road self-driving purposes is the standard race body type.\n But to be thorough, we could roughly group all of the RC cars in 4 distinct categories:\nRACE/STREET Probably the first thing that comes to mind when thinking of an RC car, a standard race car. This body type is the fastest and the best on paved, flat surfaces and is meant for on road use only.\n There is also a specialized group of RC cars of this body type that are meant for drifting on racing tracks. The main difference are the tires, which are much slicker than regular ones.\nBUGGY Buggies are the golden middle between an off-road and on road RC car. That being said, they can go off-road, unlike a regular racing car, so that makes them the best bet for people that aren't sure if they want to go off-road or on road. They are the second best thing on the road but the slowest off-road.\n TRUGGY Truggies are also an in-between body type, but they lean more to the off-road role, as opposed to the buggies. Consider them a buggy with monster truck tires.\nThey're the second fastest body type off-road, and the third fastest on road.\n TRUCKS These are your regular monster trucks. For a self-driving application, they'd be pretty bad, since they tend to flip over while making on road turns, so it's best to stick with them only if you're planning to go off road in the woods, grass or dirt.\nThey are the best for going off-road but the slowest for going on road.\n "
},
{
	"uri": "https://ori.engineering/rc-car/electric_motors/",
	"title": "Electric motors",
	"tags": [],
	"description": "",
	"content": "The main question concerning electric motors is: brushed or brushless?   Brushed pros: cheaper, simpler, better for off-road.\n  Brushed cons: heavier, bigger, worse power efficiency (75-80%), they wear out in time.\n  Brushless pros: long lifespan, much better speed and handling, better power efficiency (85-90%).\n  Brushless cons: much more expensive, worse for off-road.\n  So what should we get? It depends on your budget, but brushed motors work just fine, and besides, for self-driving purposes, you don’t need a RC car that drives 100 KPH. It’s always possible to swap out a brushed motor for a brushless later on.\n "
},
{
	"uri": "https://ori.engineering/rc-car/servo/",
	"title": "Steering servo",
	"tags": [],
	"description": "",
	"content": "An RC servo is used for controlling the steering wheels of the car. It almost always comes with the RC car, so you shouldn’t worry about getting one.\nIt typically expects around 4.8V to 6V input on the power wire (varies by car) and a PWM control signal on the signal wire. Typically, the three wires are colored black-red-white, or brown-red-yellow, where:\n the dark wire (black/brown) is ground, and the center wire (red) is power, and the light wire (white/yellow) is control.  The control signal is RC-style PWM, where one pulse is sent 60 times a second, and the width of this pulse controls how left/right the servo turns. When this pulse is:\n 1500 microseconds, the servo is centered; 1000 microseconds, the servo is turned all the way left (or right) 2000 microseconds, the servo is turned all the way in the other direction.  This is NOT the same kind of PWM that you would use to control the duty cycle of a motor, or the brightness of a LED.\n The power for the servo typically comes from the motor ESC, which has a BEC (Battery Eliminator Circuit) built in.\nSource: DonkeyCar docs.\n"
},
{
	"uri": "https://ori.engineering/rc-car/electronic_speed_controller/",
	"title": "Electronic Speed Controller",
	"tags": [],
	"description": "",
	"content": "The role of the ESC is to take a RC PWM control signal (pulse between 1000 and 2000 microseconds) in, and use that to control the power to the motor so the motor spins with different amounts of power in forward or reverse. Many RC car kits come with an ESC preinstalled, in which case you should be just fine.\nAgain, 1500 microseconds typically means \u0026ldquo;center\u0026rdquo; which for the motor means \u0026ldquo;dead stop.\u0026rdquo;\nThe battery typically connects straight to the ESC using thicker wiring than the simple control signals, because the motor draws many more amps than the control. The ESC then connects on to the motor with equally thick power wiring.\nStandard motors and ESCs have a peak current of about 12A; a 1/8th scale RC car with powerful brushless motor can have a peak draw up to 200A.\nAdditionally, the ESC typically contains a linear or switching voltage converter that outputs the power needed to control the steering servo; this is typically somewhere in the 4.8V to 6V range. Most BECs built into ESCs will not deliver more than about 1A of current, so it is not typically possible to power both the steering servo and the Jetson Nano from the BEC.\nThe main thing to look out for when getting an ESC on your own is to be sure to match your motor type to your ESC type (brushed/brushless).\n  Source: DonkeyCar docs.\n "
},
{
	"uri": "https://ori.engineering/rc-car/receiver/",
	"title": "Receiver",
	"tags": [],
	"description": "",
	"content": " If you buy a \u0026ldquo;kit car\u0026rdquo; that is listed as \u0026ldquo;needs a receiver,\u0026rdquo; then you don't need to buy a receiver.\n The Jetson Nano and the PWM/Servo driver will replace the receiver, outputting control signals to the car. If you’re buying a kit with a steering servo, motor, and ESC, you should actually try to not get a receiver, since the RC car could be specifically designed for that receivers PWM signals, and you’ll be taking it apart anyways.\n"
},
{
	"uri": "https://ori.engineering/rc-car/batteries/",
	"title": "Batteries",
	"tags": [],
	"description": "",
	"content": "There are two types of batteries used for RC cars: Nickel Metal Hydride batteries (NiMH) and Lithium Polymer batteries (LiPo).\nTL;DR: LiPo batteries are much better, but also more expensive.\nLithium Polymer batteries generally have higher current capacity (the amount of Amps the battery can deliver at one point while driving) as well as energy storage (the number of Amp Hours the battery stores when fully charged) so it may also last longer.\nThe amount of charge a battery can hold (how long it runs) is measured in Ampere-hours. The amount of current a battery can instantaneously deliver while driving is measured simply in Amperes.\n Amperes are often re-calculated in terms of multiples of the energy content, divided by one hour which is often called \u0026ldquo;C.\u0026rdquo; Thus, a LiPo rated for 10C and 2000 mAh, can deliver 20 Amperes of current while driving. A NiHM rated for 5C and 1100 mAh can deliver 5.5 Amperes of current while driving.\nBatteries can deliver more than the C rating for very short amounts of time, but will heat up or build up internal resistance so you shouldn’t count on that as being their standard capability.\nFor your custom car, be aware of the voltages needed for the ESC and the motor of the car, and make sure to get a battery that matches them in voltage.\nSmaller RC cars will come with NiMH for affordability, or 2S LiPo for power. Larger RC cars will use 3S (11.1V) or 4S (14.8V) or even 6S (22.2V) Lithium batteries, and thus need to have ESC and motor combinations to match.\nBe sure to get a charger that matches your battery.\n If you have a LiPo battery:\n get a good Lithium battery charger, with a balancing plug, never discharge a Lithium battery below 3.2V per cell  If you discharge a LiPo battery completely, it won’t ever be charged up to its normal voltage again, and trying to do so will overheat the battery and set it on fire.\n To prevent this, get a battery alarm and a LiPo charging bag:\n"
},
{
	"uri": "https://ori.engineering/host-pc/donkeycar/",
	"title": "DonkeyCar installation",
	"tags": [],
	"description": "",
	"content": "  Install miniconda Python 3.7\n  Install git\n  Make a folder for your projects:\nmkdir projects\rcd projects\r  Clone the Donkey repo:\ngit clone https://github.com/autorope/donkeycar\rcd donkeycar\rgit checkout master\r  Create the Python anaconda env:\nconda env create -f install\\envs\\windows.yml\rconda activate donkey\rpip install -e .[pc]\r  Install Tensorflow GPU:\n  Check the Software requirements for Nvidia GPUs\n  Which basically means:\n  Download and install NVIDIA drivers, obviously\n  Download and install CUDA Toolkit\n  Download and install cuDNN (you should just copy the bin, lib and include folders from the zip to your cuda installation folder)\n  Download and install TensorRT 5.0 to improve latency and throughput for inference on some models (same as the above)\n  Which means installing PyCUDA (make sure nvcc is in your PATH):\npip install \u0026#39;pycuda\u0026gt;=2017.1.1\u0026#39;\rIf you're getting errors, check the requirements here. If you're on Windows, you probably need the VS C++ 14, just download it through the VS Build Tools\n  Downloading and installing TensorRT 5.0\n        Then you can finally:\nconda install tensorflow-gpu==1.13.1\r"
},
{
	"uri": "https://ori.engineering/hardware-assembly/inventory/",
	"title": "Hardware inventory",
	"tags": [],
	"description": "",
	"content": "Let’s start with a list of all of the hardware I’ll be using through this tutorial, and of course, with the money shot:\nRC Car kit The RC Car I went with was the Tamiya TT-02, which came prebuilt and even included an receiver and a remote, for just a bit over 100€. Very lucky!\nThe reason I went with this is that it was just such a good deal for such a car. It’s 1:10 scaled, so I’ll have plenty of real estate for hooking all sorts of electronics on it, and it’s a really good car for on road driving. There’s plenty of mods available for it and plenty of extra parts, which I even got with it, such as extra wheel bases or additional mounting arms. After working with it for a couple months now, I’d highly recommend it.\nBe sure to pay attention to the level of pre-assembly your kit comes with. There are kits that can take days to assemble if you’re doing all by yourself, and there are kits that are completely pre-built out of the box (commonly denoted RTR - ready to run). If you’re up for a challenge, get a Tamiya kit that isn’t prebuilt. They have great instructions and it’s fun to get to know your car inside out. The difficulty of assembly also varies by car, and is often denoted on the box or in the instructions.\n Charger and batteries I got a Carson Expert Charger LiPo Compact 3A set, with a Carson 3000mAh LiPo battery, for under 30€, which is also pretty sweet!\nI’d very much recommend getting a ‘smarter’ charger, with a balancing connector so you know exactly how much your battery is charged. You’ll want to store them at around 70% of their capacity if you’re not using them.\n I also went ahead and got an extra Fconegy 6000 mAh LiPo battery for around 25€.\nAnd of course, per my warning on the batteries section at the RC Car primer, I got a LiPo alarm and a charging bag to avoid any unnecessary explosions, housefires or general mayhem. It’s just an extra 20€ or so, but it’s very much so worth it.\n![](/images/hardware/lipo bag.png)\nJetson Nano Ah, the 🧠z of the project, the Jetson Nano Developer Kit. It’s pretty much the way to go for 100€ or so, it packs a pretty decent GPU, 4x USB 3.0 ports, a real gigabit ethernet port, and you can punch a bit more power into it with a jumper and a 4A@5V power source with a barrel jack cable.\nJetson Nano: MicroSD card You’ll be needing a microSD card to run your Jetson Nano OS, and you should try getting a faster on (at least Class 10, preferably UHS-II or faster :)).\nI got an Sandisk Extreme 64GB A2, UHS-3 card for about 25€.\nYou don’t have to get a huge (in terms of storage) microSD if you’re planning on using an external SSD with your Jetson. I’d say 32GB would be just enough, but the price difference isn’t that big, so you can go for the 64GB version just ‘cause.\n Jetson Nano: Noctua Fan If you’re planning to run the Jetson at fully capacity (4A barrel jack mode), which you most definitely should, it’s gonna need some help stayin’ cool, so you should get a fan for it.\nYou can pretty much get any 5V, 4-pin PWM, 40x40mm size fan, but I’d very much recommend going for a Noctua NF-A4 fan. You can choose between the 10mm or 20mm version, just be sure to get the 5V version of the fan and not the regular 12V one.\nYou can get the 20mm version for about 10-15€.\nYou’ll also want a couple of self-tapping M3 screws or regular M2 or M2.5 screws with nuts for mounting the fan to the heatsink. I’d recommend going with the self-tapping M3 screws, it’s so much easier. Also watch out for some aluminum shavings when you mount the fan on it, you wouldn’t want them getting to the circuitry below and causing mayhem.\n Also, if you’re going with the 20mm version, get 25mm long screws. If you’re going with the 10mm version, get 15mm long screws.\n Jetson Nano: Wireless LAN and Bluetooth There are two options on getting your Nano (and your car) wirelessly connected:\n An M.2 WiFi + BT card USB WiFi and BT adapters  I’d highly recommend going for the M.2 option. I got the Intel 8265 card for about 10€.\nIf you’re getting the M.2 variant, you’ll need two antennas and an IPEX MHF4 to RP-SMA adapter cable. Pay attention to the connector types, it’s easy to get a wrong one, and vendors often misuse the labels, mixing IPEX, uFL, IPAX, IPX, MHF, and AM. Sometimes they’re right, sometimes they’re not.\n The Jetson Nano has a M.2 key E slot, just to keep in mind when getting a card. It also doesn’t work with NVME SSDs, if you’re wondering.\n Beware of the model of the m.2 card you’re getting. At the time of writing, the Jetson Nano SD Card Image natively supports only the 8265. Technically, you should be able to use any Intel card older than the 8265 since it’s supported in the 4.9 kernel, but some people had issues running even the 7265. If you’re up to it, you can build the core14 branch on the backports git, but if you know how to do that, you probably don’t need me telling it about you.\n Jetson Nano: Camera To enable the car to look around itself and navigate itself, you’ll need a camera. You can use pretty much any USB camera, or you can use a MIPI CSI camera with the Nano.\nThe cool thing about the Jetson Nano is that it’s compatible with almost all Raspberry Pi products, which includes camera.\n I went with the Raspberry Pi Camera v2, which uses the IMX219 sensor.\nI’d recommend getting an extra longer flat cable, so you don’t have to worry about the positioning of the camera relative to the Nano on the vehicle, since you only get a rather short one with the camera you buy.\n Now, about the almost all RPi products part mentioned above. If you’re buying a RPi Camera, make sure to get the newer version with the IMX219 sensor instead of the older (EOL) OV5647 sensor, since it’s not supported by the Jetson Nano image. Of course, you can build the drivers into the kernel yourself, but I’d go with the pragmatic solution on this one.\n I may also be using an Elephone EleCam Explorer Elite 4K cam I had lying around as an additional camera just for fun.\nPCA9685 Servo Driver To enable your Jetson Nano to interface with your steering servo and ESC, you’ll need a PWM/Servo Driver. I’ll be using the PCA9685 over I2C, which is pretty cheap and has lots of extra channels.\nYou might want to get some jumper cables if you don’t have any lying around, since you’ll have to connect this to the Jetson Nano’s GPIO pins somehow.\n Jetson Nano: Power bank To power all of this for a reasonable amount of time, you’ll want to get a pretty good power bank. I went with the RAVPower 20100 mAh USB-C power bank with 45W PD for about 50€.\nYou can pretty much get any power bank you’d like, but I’d recommend getting something above 10Ah and more than 2A if you plan on using the barrel jack connection on the Nano.\nJetson Nano: (Optional) External SSD First of all, why:\n With a microSD, on average you’ll get ~ 87 MB/s read speed with an access time of ~0.52 milliseconds. With a SSD, you’ll get an average read rate of ~367 MB/s and an access time of ~0.29 milliseconds.  So go ahead and get an NVMe SSD and an external USB enclosure for it. I’ll be using a LITE-ON SSD I had lying around after replacing my Razer Blade Stealth OEM one with a Samsung 970 Evo.\nGetting an external NGFF/M.2 SSD enclosure can be a very much hit-or-miss business if you’re trying to save a couple of bucks. I got lucky and got an off-brand one working at very decent speeds for some 20€. Other people I know haven’t been that lucky on their first attempt, so beware when buying it, make sure there’s an option to return it if it doesn’t work. :)\n Although this gives you about 4x more speed with your Nano, it is fairly technical and complicated and includes manually patching and building a Linux kernel, so I can only assume that you’re very very interested, since it’s so much fun. You’re here to build a nothing less than a self-driving vehicle, what’s a little kernel hacking compared to it. :)\n Jetson Nano: (Optional) Camera Lens Attachments If you’re getting the standard Raspberry Pi Camera, it won’t have much of a FOV by itself. One thing you can do, is get one of the clip-on attachment lenses for smartphones, which can greatly increase its FOV.\nI got something like this:\nThese lenses are what they are, cheap. With cheap lenses come all sorts of nasty stuff, like chromatic aberration and barrel distortion. Try to look at some of the customer reviews that contain photos and find one with a bit less distortion.\n The Rest: Tools and stuff Of course, you’ll need some basic tools, such as:\n A good scalpel A cutting board A hand drill (depending on what you’re planning to use as your base) Screwdrivers with an assortment of M3 screws (various lengths, with nuts)  But that’s pretty much it for the inventory. On to building it!\n"
},
{
	"uri": "https://ori.engineering/hardware-installation/jetson-nano-installation/",
	"title": "Jetson Nano installation",
	"tags": [],
	"description": "",
	"content": "We’ll begin by preparing installing the Jetson Nano image and setting up the software neccessary to connect it to the RC Car via the PCA Servo Driver.\nPreparing the microSD The official Jetson Nano docs are great and you can just follow them until the Next Steps step.\n If you want a TL;DR version:\n  Download the Jetson Nano Developer Kit SD Card Image\n  Format your microSD card and then flash the image on it using whatever tool you’d like.\n You can use Etcher    Insert the microSD into the Jetson and connect your peripherals to it: monitor, keyboard, mouse and an ethernet cable.\n  ![Jetson](/images/jetson animation.gif)\nIf you’re using Windows, after the flashing it’ll complain you need to format the microSD before you use it, since it doesn’t recognize the Linux filesystem you just flashed on it. Don’t format it, just ignore the warning.\n First boot The TL;DR version would be:\n Carefully read through the NVIDIA Jetson software EULA and decide if you’ll accept it 🙃 Select the system language, keyboard layout and time zone Create your user and name your Jetson Log in  If all went well, you should see the following screen:\n![First boot](/images/first boot.png)\nCongrats, you’ve set up the base OS for the Jetson. On to the fun part!\n"
},
{
	"uri": "https://ori.engineering/hardware-assembly/building-the-car/",
	"title": "Assembling the RC Car",
	"tags": [],
	"description": "",
	"content": "Now to the fun part: building the RC car. This will vary very much based on your RC Car kit. If it’s ready-to-run (RTR), you should be good out of the box. If it’s an unassembled kit, you’ve got a ton of work ahead, just follow the instructions that came with the car. If you’re like me, and got something in between, you’ll have just a bit of work before running it.\nIn my case, I had to assemble the wheels and mount them on the car, and that was pretty much it. Other than that, I had to calibrate my ESC as per the instructions and my car was ready to go.\n\rI found it helpful to have a ‘bro nearby that’s willing to help you assemble and Google stuff for you since you’re lazy to read the instructions completely. YMMV based on the brother that’s available to you.\n Pics or it didn’t happen Test drive After assembling the car, take it for a spin. If it works, you’re ready to move on to the electronics part of the project. :)\n\r"
},
{
	"uri": "https://ori.engineering/hardware-installation/kernel-hacking/",
	"title": "Running the OS from an external SSD using a custom kernel",
	"tags": [],
	"description": "",
	"content": "This is the technical, optional upgrade that will enable you to boot your OS from an external SSD.\nSyonyk has an awesome Jetson Nano guide with all of this stuff explained and was the primary source of info while researching how to do this.\n JetsonHacks also have a guide that should make this much easier to do, as they’ve prepared scripts that do all of the work for you, but I haven’t tried it so I can’t say it works for sure, but it should!\n This will take some time. Taking kernels apart, patching them and building them takes a while even on your regular workstations or servers, but doing it on an embedded device is a whole new world of pain when it comes to waiting for stuff to build, compile or extract. Be prepared to be patient while you’re doing this.\n So what is it we’re exactly planning to do here, and why? We want to use our external SSD as the root filesystem because of the huge performance boost it gives us. But the problem is this:\n The USB 3 ports require the kernel to load some firmware on boot to enable them to work, which means the USB ports won’t work until the device boots up That firmware is stored on the root filesystem, which we want to, you know, put on our external SSD That means we’d need the firmware from our SSD in order to use our SSD…  So, how can we work this out? Simple: patch the kernel and embed the firmware we need right into it, so it doesn’t need to read it from the root filesystem, which we can then freely put on our external SSD.\nWhile we’re at it, there’s another thing that would give us a noticeable performance boost which we could build into the kernel, same-filled page merging support for zswap.\nOkay, hack all the kernels All of the steps written below are meant to be run directly on your Jetson Nano.\n First of all, since the Nano doesn’t run the stock Linux kernel, we’ll need the sources for its custom kernel. Miraculously Nvidia actually provides it.\n Download the BSP Sources from the right side, under Jetson Nano on the L4T download page. Unpack the archive Unpack the kernel source from the public sources folder to your home directory Open the kernel folder  Steps shown below:\ncd Downloads\rtar -xf public_sources.tbz2\rcd ~\rtar -xf ~/Downloads/public_sources/kernel_src.tbz2\rcd ~/kernel/kernel-4.9\rOnce we’re in the kernel directory, we’ll save the current kernel configuration from the Nano to it:\nzcat /proc/config.gz \u0026gt; .config\rNow we need to copy the USB firmware from the root filesystem into the kernel directory, since we want to pack it together with the kernel:\ncp /lib/firmware/tegra21x_xusb_firmware ./firmware/\rNow we need to change the kernel config, and since we’re using a GUI desktop environment on the Nano, we can just use menuconfig:\nsudo apt-get install libncurses5-dev\rmake menuconfig\rYou should see something like this:\n![](/images/kernel hacking/menuconfig1.jpg)\nWhen selecting kernel features in menuconfig, * denotes a built-in feature and M denotes a module. You’ll be wanting stars for the features you want to build in.\n  Go to Kernel features:  Select: Enable frontswap to cache swap pages if tmem is present Select: Compressed cache for swap pages (EXPERIMENTAL) (NEW) Select: Low (Up to 2x) density storage for compressed pages    We didn’t select the 3x allocator (z3fold) because isn't reliable prior to mid-4.20 kernel versions. With same-filled page merging, the results are about the same as the zbud 2x allocator.\n  Exit Go to Device Drivers  Generic Driver Options  External firmware blobs to build into the kernel binary  Type: “tegra21x_xusb_firmware”     Exit   Save the new configuration  ![](/images/kernel hacking/menuconfig2.jpg)\n![](/images/kernel hacking/menuconfig3.jpg)\nNow we’ll update ZSwap to enable same-filled page compression. The kernel that the Jetson Nano is running at the time of writing is 4.9, which doesn’t include it, but it can easily be backported from a newer kernel.\nOne of the best things about Linux, what makes it what it is, is that it’s available for everyone, and we can find it on Linus Torvalds’ GitHub:\n Go to the Linux kernel source on GitHub Go to mm/zswap.c Take a look at the commit history by clicking on the History button Find the zswap: same-filled pages handling commit  On GitHub, you can add .patch at the end of the URL to get the patch file for the commit you’re looking at. Just be sure to remove the #diff parameter from the URL if you’re looking at the diff from the commit.\n  Download the patch file for the same-filled pages commit Patch the kernel using patch -p1 and the downloaded patch There is a memset_l call in the patch we’ve just applied, and it doesn’t exist yet in the 4.9 kernel, so we’ll need to replace it with the regular memset.  See instructions below:\nMake sure you’re in the kernel-4.9 directory before proceeding.\n # You should be in the Downloads directory\rwget https://github.com/torvalds/linux/commit/a85f878b443f8d2b91ba76f09da21ac0af22e07f.patch\r# Change to the kernel directory\rcd ~/kernel/kernel-4.9\rpatch -p1 \u0026lt; ~/Downloads/a85f878b443f8d2b91ba76f09da21ac0af22e07f.patch\r# Replace the nonexistent memset_l call with the regular memset\rsed -i \u0026#39;s/memset_l(page, value, PAGE_SIZE \\/ sizeof(unsigned long));/memset(page, value, PAGE_SIZE);/g\u0026#39; mm/zswap.c\r![](/images/kernel hacking/patching kernel.png)\nBuilding and installing the kernel Now that we’ve made all of the changes we wanted to the kernel, we need to build it and place it on the /boot partition.\nThis will take a while.\n # Make sure we\u0026#39;re in the kernel directory\rcd ~/kernel/kernel-4.9\rmake -j5 # -j denotes the number of threads\rsudo make modules_install\rsudo cp /boot/Image /boot/Image.dist\rsudo cp arch/arm64/boot/Image /boot\r![](/images/kernel hacking/building kernel.png)\nAfter this is done, you can reboot. If the Nano boots successfully, it means that you’re running your new custom kernel. You can run uname -r to check it:\n# The stock kernel returns \u0026#39;4.9.140-tegra\u0026#39;\r# Your custom kernel should return only \u0026#39;4.9.140\u0026#39;\runame -r\rIf all is well, we can transfer our root partition to the external SSD.\nThis will also take a while when you get to the copying of the root filesystem to the SSD.\n  Plug the SSD in Wipe the partition table Create a GPT partition table Create a new EXT4 volume 4 gigabytes smaller than the SSD Create a 4 gigabytes swap partition  See steps below:\n# Wipe the partition table\rsudo dd if=/dev/zero of=/dev/sda bs=1M count=1\r# Create a GPT partition table, then create a new EXT4 volume\r# Create a Linux swap partition (4GB) - arrow over to \u0026#34;Type\u0026#34; and select \u0026#34;Linux swap\u0026#34;\r# Go over to \u0026#34;Write\u0026#34; and type \u0026#34;yes\u0026#34; and then quit\rsudo cfdisk /dev/sda\r# Make an ext4 volume and a swap partition\rsudo mkfs.ext4 /dev/sda1\rsudo mkswap /dev/sda2\r# Mount the partition and copy the root filesystem to it\rsudo mkdir /mnt/root\rsudo mount /dev/sda1 /mnt/root\rsudo mkdir /mnt/root/proc\rsudo apt -y install rsync\rsudo rsync -axHAWX --numeric-ids --info=progress2 --exclude=/proc / /mnt/root\r Edit /boot/extlinux/extlinux.conf so that the kernel points at /dev/sda1 instead of /dev/mmcblk0p1 (the microSD) Enable zswap in extlinux.conf  sudo sed -i \u0026#39;s/mmcblk0p1/sda1/\u0026#39; /boot/extlinux/extlinux.conf\rsudo sed -i \u0026#39;s/rootwait/rootwait zswap.enabled=1/\u0026#39; /boot/extlinux/extlinux.conf\rReboot, and you should be running from the USB SSD.\nIf you mess something up and the Nano doesn’t boot, don’t worry, you can always plug the microSD into a Linux PC and mount it, go to the boot partition and open the extlinux/extlinux.conf file and replace sda1 with mmcblk0p1 so it boots from the microSD.\n If you somehow end up messing up the extlinux.conf file, I’ve provided a copy for you down below, so you can overwrite it as stated in the tip above and boot back to the microSD:\n TIMEOUT 30\rDEFAULT primary\rMENU TITLE p3450-porg eMMC boot options\rLABEL primary\rMENU LABEL primary kernel\rLINUX /boot/Image\rINITRD /boot/initrd\rAPPEND ${cbootargs} rootfstype=ext4 root=/dev/sda1 rw rootwait\rTweaking swap One last thing to do after you boot from your SSD, enable swap:\necho \u0026#34;/dev/sda2 none swap \\\rdefaults 0 1\u0026#34; | sudo tee -a /etc/fstab\rAnd you’re done. Congrats on hacking the kernel and running your Nano from an external SSD. It’ll be worth it!\n"
},
{
	"uri": "https://ori.engineering/host-pc/simulator/",
	"title": "Simulator installation",
	"tags": [],
	"description": "",
	"content": "  Download and unzip the simulator for your platform from the DonkeyCar GitHub release page\n  Place the simulator into your projects folder (where you cloned the Donkey repo)\n  Install DonkeyGym:\ncd ~/projects\rgit clone https://github.com/tawnkramer/gym-donkeycar\rconda activate donkey\rpip install -e gym-donkeycar\r  Create a new donkey application for your simulator:\ndonkey createcar --path ~/mysim\rcd ~/mysim\r  Edit the myconfig.py file inside the application folder you just created (mysim):\n# Enables the Donkey Gym simulator wrapper\r DONKEY_GYM = True\rDONKEY_SIM_PATH = \u0026#34;/home/wherever/your/projects/are/DonkeySimFolder/DonkeySim.exe\u0026#34;\r# Choose the track you want to run, you can change this later\r DONKEY_GYM_ENV_NAME = \u0026#34;donkey-generated-track-v0\u0026#34;\r  Download this test dataset that contains data of a car recovering from dropping out from the track and some standard driving data and put it in your data folder inside your application folder (/mysim/data/)\n  Train your model by running\npython manage.py train --model models/mymodel.h5\r You can choose different architectures or create your own by going into the donkeycar parts folder (/projects/donkeycar/parts/) and opening up the keras.py script. You can define a new class that inherits the base class for models and implement your own neural network architecture (just take a look at the other classes, you'll get it). After creating your own architecture/class, you can train the model using it by passing the flag \u0026ndash;type=yourClassName Some of the built-in models are: categorical, linear, rnn, 3d, latent, etc. When using your custom model to drive the car, if you get some dimensions errors, try passing the \u0026ndash;type flag along with your class name while running it, it should fix it.    Test your model by running\npython manage.py drive --model models/mymodel.h5\rUse \u0026ndash;type=yourCustomClass if you're trained it using a custom class and are getting some errors.\n Open up your browser and go to: http://localhost:8887 and set the mode to Local Pilot and watch your car go! If you're using Linux, you can also pass the \u0026ndash;js parameter and use your gamepad if it's mounted to /dev/js0    Download this big dataset that contains 16 different venues with tape lined tracks on concrete and tile (some are on carpet and cobblestones)\n Credits to Tawn from the Donkey Slack channel    "
},
{
	"uri": "https://ori.engineering/hardware-assembly/mounting-plates/",
	"title": "Building the mounting plates for the hardware",
	"tags": [],
	"description": "",
	"content": "There are many options to go for when it comes to mounting your Nano and the rest of the hardware to your RC car.\nOption 1: 3D printing If you’re planning on 3D printing your parts, take a look at:\n The official DonkeyCar docs which contain a lot of 3D models for printing: chassis and adapters, mounting plates, more mounting plates, etc. Markku.ai’s Chilicorn Rail for the Tamiya cars  I actually used the Chilicorn Rail for the first iteration of my build, and was very lucky to have been introduced by my mentor to Mitch, who printed out the parts and helped me out with a ton of stuff since then:\nEven if you’re not planning on using this method, I’d still recommend at least getting the RPi camera mount 3D printed, since it’s kinda difficult to get it to the right angle and position if you’re making something out of raw materials yourself.\n Option 2: Hack something together yourself If you’re planning on hacking something together by yourself, you can pretty much do anything you want. I used a special aluminium plate I got as a donation for my thesis from my mentor’s father :):\nAfter some modeling and tinkering, I came up with the following idea for my mounts:\n\rThe only thing left now is to measure the aluminium, mark down where to drill the screw holes and assemble it together, but being the lucky man that I am, my hand drill broke down just as I wanted to drill the aluminium, but fear not, I had this bad boy standing by:\rAnd after measuring up the dimensions and taking my materials, much to my surprise, I successfully drilled up my plates and got this:\nWith some zip-tie magic and screwing around 🙃 this was the end result:\nNevermind the disconnected antennae, we’ll get to that in a second.\nThat should be it as far as the ‘dumb’ part of the hardware is concerned. On to connecting all of the stuff together and setting up the Nano! "
},
{
	"uri": "https://ori.engineering/hardware-assembly/jetson-nano-installation/",
	"title": "Preparing the Jetson Nano",
	"tags": [],
	"description": "",
	"content": "Before we begin assembling our hardware together, we should first prepare our Jetson Nano by installing an OS on it and verifying everything works before it gets buried among all the other hardware on the RC.\nPreparing the microSD First, we'll prepare the microSD by installing an OS on it for the Nano to run.\nThe official Jetson Nano docs are great and you can just follow them until the Next Steps step.\n If you want a TL;DR version:\n  Download the Jetson Nano Developer Kit SD Card Image\n  Format your microSD card and then flash the image on it using whatever tool you’d like.\n You can use Etcher    Insert the microSD into the Jetson and connect your peripherals to it: monitor, keyboard, mouse and an ethernet cable.\n  If you’re using Windows, after the flashing it’ll complain you need to format the microSD before you use it, since it doesn’t recognize the Linux filesystem you just flashed on it. Don’t format it, just ignore the warning.\n First boot The TL;DR version would be:\n Carefully read through the NVIDIA Jetson software EULA and decide if you’ll accept it 🙃 Select the system language, keyboard layout and time zone Create your user and name your Jetson Log in  If all went well, you should see the following screen:\nCongrats, you’ve set up the base OS for the Jetson. On to the fun part!\n"
},
{
	"uri": "https://ori.engineering/hardware-assembly/assembling-the-nano/",
	"title": "Assembling the Jetson Nano",
	"tags": [],
	"description": "",
	"content": "Now we can finish up our Nano by connecting the WLAN card, microSD and the fan to it.\nPlugging in the microSD I actually already did a lot of assembly some time ago, and I'm writing this in retrospect, so don't be worried if my Nano has a lot of stuff already hooked up to it and if it looks a bit different than yours, just focus on the stuff we're going through and disregard the rest.\n First, we have to take out the Nano module from the breakout board we got it with. We begin by unscrewing these two Phillips screws, highlighted in yellow:\nAfter unscrewing them, pull these two levers outwards (highlighted in yellow) and your Nano module will pop out:\nThe Nano should pop out like this:\nAnd after pulling it out, you can plug in your microSD on the bottom side:\nConnecting the Noctua fan to the Nano On the other side of the module, you can find the heatsink with four screw holes into which, if you haven't done so already, you can screw in the fan you bought for your Nano:\nYou also need to plug in the 3-pin (or 4-pin) fan connector to the Jetson board right below the ethernet port:\nPlugging in the WLAN+BT card The only thing left is the wireless card, which is plugged into the slot at the middle of the breakout board. You just need to unscrew one Phillips screw, insert the card, put the screw back in and connect your antennae connectors to the WLAN card. The antennae are the same, so don't worry where to plug which one, it doesn't matter.\nAnd that's it for the Nano board! After putting it all back together, and connecting the antennae, it looks something like this:\n"
},
{
	"uri": "https://ori.engineering/hardware-assembly/connecting-the-car-to-the-nano/",
	"title": "Connecting the RC to the Nano",
	"tags": [],
	"description": "",
	"content": "Now comes the part that should differ the most, based on the RC you got. But don't worry, it's very much doable no matter the RC you got!\nFinding your ESC/Servo The first thing you should do is find your ESC and your Servo connectors, which should be a three wire connector coming from your RC car.\nIf you've bought a car that came with a wireless receiver, both the connectors should be connected to it. Here's what it looked like on my RC:\nIf you didn't have a wireless receiver, you should be able to see a connector coming out of your ESC, which is hooked to the RC motor, and a connector coming out of your steering servo, found at the front of your RC.\nHere's a closeup of the two connectors connected to the receiver, with the first channel being the steering servo and the second one being the ESC, in my case:\nI2C Why I2C Serial UART:  Serial ports are asynchronous (no CLK), so both devices have to agree to use a data rate - any excessive clock difference will result in garbled data Requires hardware overhead - the UART at either end is relatively complex and difficult to accurately implement in software if necessary. At least one start and stop bit is a part of each frame of data, meaning that 10 bits of transmission time are required for each 8 bits of data sent, which eats into the data rate. Two, and only two devices - bus contention (where two devices attempt to drive the same line at the same time) is always an issue and must be dealt with carefully to prevent damage to the devices in question, usually through external hardware. Data rate - only a fixed number of baud rates available, highest of which is usually 230400 bits per second.  SPI:  Number of pins - four lines for a single master -\u0026gt; slave connection and each additional slave needs another chip select I/O pin on the master A larger number of devices rapidly proliferates the connections - routing signals sucks, sometimes impossible in tight PCB situations It's pretty good for high data rate full-duplex connections (10MHz - bits), scales nicely The hardware is pretty simple - a shift register, easy software implementation  I2C  I2C requires a mere two wires, like asynchronous serial, but those two wires can support up to 1008 slave devices. Also, unlike SPI, I2C can support a multi-master system, allowing more than one master to communicate with all devices on the bus (although the master devices can't talk to each other over the bus and must take turns using the bus lines). Data rates fall between asynchronous serial and SPI; most I2C devices can communicate at 100kHz or 400kHz. There is some overhead with I2C; for every 8 bits of data to be sent, one extra bit of meta data (the \u0026ldquo;ACK/NACK\u0026rdquo; bit) must be transmitted. The hardware required to implement I2C is more complex than SPI, but less than asynchronous serial. It can be fairly trivially implemented in software.  I2C Signals Each I2C bus consists of two signals: SCL and SDA.\n SCL is the clock signal, and SDA is the data signal. The clock signal is always generated by the current bus master; some slave devices may force the clock low at times to delay the master sending more data (or to require more time to prepare data before the master attempts to clock it out). This is called \u0026ldquo;clock stretching\u0026rdquo;.  PWM PWM is a digital (i.e. square wave) signal that oscillates according to a given frequency and duty cycle.\n The frequency (expressed in Hz) describes how often the output pulse repeats. The period is the time each cycle takes and is the inverse of frequency. The duty cycle (expressed as a percentage) describes the width of the pulse within that frequency window.  You can adjust the duty cycle to increase or decrease the average \u0026ldquo;on\u0026rdquo; time of the signal. The following diagram shows pulse trains at 0%, 25%, and 100% duty:\n Note: Most PWM hardware has to toggle at least once per cycle, so even duty values of 0% and 100% will have a small transition at the beginning of each cycle.\n Example: LED Brightness  20% duty cycle at 100 Hz or above will just look dimmer than fully on  PCA9865   Adjustable frequency PWM up to about 1.6 KHz\n  12-bit resolution for each output - for servos, that means about 4us resolution at 60Hz update rate, 4096 levels\n  Multiple Drivers (up to 62) can be chained to control still more servos. With headers at both ends of the board, the wiring is as simple as connecting a 6-pin parallel cable from one board to the next.\n  Board 0: Address = 0x40 Offset = binary 00000 (no jumpers required)\n  Board 1: Address = 0x41 Offset = binary 00001 (bridge A0)\n  Board 2: Address = 0x42 Offset = binary 00010 (bridge A1)\n  Board 3: Address = 0x43 Offset = binary 00011 (bridge A0 \u0026amp; A1)\n  Board 4: Address = 0x44 Offset = binary 00100 (bridge A2)\n  Board 5: \u0026hellip;\n  PWM Controlled Servo  PWM signals go into the signal demodulation circuit through the receiving channel, so to generate a DC bias voltage. It will then be compared with the voltage of the potentiometer, and thus a voltage gap is obtained and input into the motor driver IC to drive the motors to rotate clockwise or anticlockwise. When the speed reaches to a certain number, it will drive the potentiometer R to rotate by the cascaded reduction gear, until the gap is reduced to 0 and the servo stops spinning. A servo is controlled by PWM signals, and the change of duty cycle control that of the position the servo rotates to.  A typical servo motor expects to be updated every 20 ms with a pulse between 1 ms and 2 ms, or in other words, between a 5 and 10% duty cycle on a 50 Hz waveform.\nThe period of 20 ms (50 Hz) comes from the days where the signal was encoded in PPM format to be sent over the air.\nThe PPM period was around 22.5 ms, and the conversion to PWM was trivial: the time of the PWM high state was the time position of the PPM pulse for that servo.\nRC Servo   Modern RC servo position is not defined by the PWM duty cycle (ON/OFF time) but only by the width of the pulse.\n  The frequency doesn't matter as long as it is between 40 Hz and 200 Hz.\n  Typically expects around 4.8V to 6V input on the power wire (varies by car) and a PWM control signal on the signal wire.\n  Three wires are colored black-red-white, or brown-red-yellow, where the dark wire (black/brown) is ground, and the center wire (red) is power, and the light wire (white/yellow) is control.\n  RC-style PWM:\n One pulse is sent 60 times a second, and the width of this pulse controls how left/right the servo turns. 1500 microseconds - the servo is centered; 1000 microseconds - the servo is turned all the way left (or right); 2000 microseconds - the servo is turned all the way in the other direction    RC ESC  Pulse between 1000 and 2000 microseconds Controls the power to the motor so the motor spins with different amounts of power in forward or reverse. Again, 1500 microseconds typically means \u0026ldquo;center\u0026rdquo; which for the motor means \u0026ldquo;dead stop.\u0026rdquo;  My schematic: ![PCA9865 assembly_bb](C:\\Users\\ori\\Desktop\\Masters\\sketches and docs\\PCA9865 assembly_bb.png)\n Note to self: It is not a good idea to use the Jetson 5v pin to power your servos. Electrical noise and \u0026lsquo;brownouts\u0026rsquo; from excess current draw can cause the Nano to act erratically, reset and/or overheat.\n Calibrating the RC # Find the i2c bus\rsudo i2cdetect -l\r# PCA9865 default address is 0x40 @ the connected bus\rsudo i2cdetect -r -y 1\r# Donkey calibration utility\rdonkey calibrate --channel n --bus=n\rCalibrate utility source\nThe function for setting the pulse: set_pulse\nManufacturer lib\nThe Neural Net https://paperswithcode.com/task/lane-detection/codeless\n"
},
{
	"uri": "https://ori.engineering/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ori.engineering/",
	"title": "Ori Engineering",
	"tags": [],
	"description": "",
	"content": "Hi there! My name is Ivan, and I’m currently working on a self-driving RC car for my Master’s thesis. This website is meant to be a guide/tutorial for all those interested in making their own self-driving RC, and will be updated regularly to document my progress working on it.\nFeel free to ping me at  Twitter  or at my  E-mail  if you want to get in touch or know more/ask anything.\n"
},
{
	"uri": "https://ori.engineering/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]